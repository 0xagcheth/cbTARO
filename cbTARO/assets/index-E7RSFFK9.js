import{createConfig as a,http as f}from"https://esm.sh/wagmi@2.12.0";import{base as d}from"https://esm.sh/wagmi@2.12.0/chains";import{farcasterMiniApp as w}from"https://esm.sh/@farcaster/miniapp-wagmi-connector@1.1.0";import{injected as u}from"https://esm.sh/wagmi@2.12.0/connectors";import{QueryClient as p}from"https://esm.sh/@tanstack/react-query@5.28.0";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const n of o)if(n.type==="childList")for(const t of n.addedNodes)t.tagName==="LINK"&&t.rel==="modulepreload"&&s(t)}).observe(document,{childList:!0,subtree:!0});function i(o){const n={};return o.integrity&&(n.integrity=o.integrity),o.referrerPolicy&&(n.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?n.credentials="include":o.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(o){if(o.ep)return;o.ep=!0;const n=i(o);fetch(o.href,n)}})();window.wagmiConfig=a({chains:[d],transports:{[d.id]:f()},connectors:[w(),u()]});console.log("[BOOT] Wagmi config loaded");window.queryClient=new p({defaultOptions:{queries:{queryKeyHashFn:r=>JSON.stringify(r,(e,i)=>typeof i=="bigint"?i.toString():i)}}});console.log("[BOOT] QueryClient created");window.__fc={sdk:null,sdkPromise:null,provider:null,providerPromise:null,readyCalled:!1};async function c(){return window.__fc.sdk?window.__fc.sdk:(window.__fc.sdkPromise||(console.log("[FC] importing miniapp sdk..."),window.__fc.sdkPromise=(async()=>{try{const r=await import(window.__SDK_URLS.fc);window.__fc.sdk=r.sdk;const e=Object.keys(window.__fc.sdk||{}).join(", ");return console.log("[FC] imported keys:",e),window.__fc.sdk}catch(r){throw console.error("[FC] SDK import failed:",r),r}})()),window.__fc.sdkPromise)}async function l(){var r;if(window.__fc.readyCalled){console.log("[FC] ready() already called, skipping");return}try{const e=await c();(r=e==null?void 0:e.actions)!=null&&r.ready?(await e.actions.ready(),window.__fc.readyCalled=!0,console.log("[FC] ✅ actions.ready() ok")):console.log("[FC] sdk.actions.ready not available")}catch(e){console.log("[FC] ready() skipped (not in miniapp)",e)}}async function m(){return console.log("[FC] fcProvider() called"),console.log("[FC] window.__fc.provider cached:",!!window.__fc.provider),console.log("[FC] window.__fc.providerPromise exists:",!!window.__fc.providerPromise),window.__fc.provider?(console.log("[FC] Returning cached provider"),window.__fc.provider):window.__fc.providerPromise?(console.log("[FC] Returning existing providerPromise"),window.__fc.providerPromise):(console.log("[FC] Creating new providerPromise..."),window.__fc.providerPromise=(async()=>{var r;try{console.log("[FC] Loading SDK for provider...");const e=await c();console.log("[FC] SDK loaded, checking sdk.wallet:",!!(e!=null&&e.wallet)),console.log("[FC] sdk.wallet.getEthereumProvider available:",typeof((r=e==null?void 0:e.wallet)==null?void 0:r.getEthereumProvider)=="function");const i=await e.wallet.getEthereumProvider();return console.log("[FC] ✅ got ethereum provider from sdk:",!!i),console.log("[FC] Provider type:",typeof i),console.log("[FC] Provider has request method:",typeof(i==null?void 0:i.request)=="function"),window.__fc.provider=i,i}catch(e){return console.error("[FC] ❌ ethereum provider not available:",e),console.error("[FC] Error details:",{message:e.message,stack:e.stack,name:e.name}),null}})(),window.__fc.providerPromise)}window.loadFcSdk=c;window.fcReadyOnce=l;window.fcProvider=m;l();
